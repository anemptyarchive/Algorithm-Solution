---
title: "『問題解決力を鍛える！　アルゴリズムとデータ構造』"
subtitle: "第12章 ソート"
author: "[@anemptyarchive](https://www.anarchive-beta.com/)"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output: 
  html_document: 
    toc: TRUE       # 目次
    toc_depth: 3    # 目次の見出しレベル
    toc_float: TRUE # 目次のスクロール追跡
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE, error = FALSE, warning = FALSE # メッセージを非表示
)
```

----

【編集履歴】

- 2023.08.16：執筆開始
- 2023.08.16：「挿入ソート」を追加
- 2023.08.20：「マージソート」を追加
- 2023.08.30：「バケットソート」を追加

----

# 12.3 挿入ソートの実装と可視化

　挿入ソート(insertion sort)を実装します。また、ソートの推移のアニメーションを作成して、アルゴリズムを確認します。  
<br>

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(gganimate)
```

```{r, echo=FALSE}
### 資料作成用

# チェック用
library(ggplot2)
```

　この記事では、基本的に `パッケージ名::関数名()` の記法を使っているので、パッケージを読み込む必要はありません。ただし、作図コードについてはパッケージ名を省略しているので、`ggplot2` を読み込む必要があります。  
　また、ネイティブパイプ演算子 `|>` を使っています。`magrittr` パッケージのパイプ演算子 `%>%` に置き換えても処理できますが、その場合は `magrittr` を読み込む必要があります。  

　「ソートの可視化」において、`gganimate` パッケージを利用してアニメーション(gif画像)を作成します。ソートの実装自体には使いません。  
<br>


## ソートの実装

　まずは、挿入ソートのアルゴリズムを関数として実装します。  
<br>

　挿入ソートを実装します。

```{r}
# 挿入ソートの実装
insertion_sort <- function(vec) {
  
  # 数列の要素数を取得
  N <- length(vec)
  
  # 要素ごとに処理
  for(i in 2:N) { # (1番目は不要)
    
    # i番目の値を取得
    val <- vec[i]
    
    # i番目から逆順に挿入位置jを探索:(j ≤ i)
    for(j in (i-1):0) { # (i番目は不要・0番目は挿入処理との兼ね合い用)
      
      # j番目とi番目の値を大小比較
      if(j <= 0) {
        
        # 全要素を比較したらループを終了
        break
        
      } else if(vec[j] > val) {
        
        # j番目の値を1つ後に移動
        vec[j+1] <- vec[j]
        
      } else {
        
        # i番目の値以下ならループを終了
        break
      }
    }
    
    # i番目の値をj番目に挿入
    vec[j+1] <- val
  }
  
  # 数列を出力
  return(vec)
}
```

　数列を `vec`、数列の要素数を `N` とします。  
　`vec` の `1` 番目から `N` 番目まで(を `i` として)の要素を順番に入れ替えていきます。ただしアルゴリズム上、1番目の要素は入れ替えが行われないので、処理を省略します。  
　`vec` の `i` 番目の要素 `vec[i]` の入れ替えでは、`i` 番目から `1` 番目まで(を `j` として)の要素を順番に大小比較します。ただしアルゴリズム上、i番目の要素は入れ替えが行われないので、処理を省略します。  

　`i` 番目の要素 `vec[i]` を `val` としておき、`val` と `j` 番目の要素 `vec[j]` を比較します。  
　`j` 番目の値が大きければ、`j` 番目の値を `j+1` 番目の値に複製します。この操作が、j番目の要素を1つ後に移動するのに対応します。ただしこの時点では、j番目とj+1番目が同じ値です。  
　`j` 番目の値が小さければ、`break` でループ処理を終了して、`j+1` 番目の要素を `val` で上書きします。この操作が、値の挿入に対応します。j+1番目の値は、1つ前の試行においてj+2番目に移動(複製)されています。  
　全ての要素が大きかった場合は、`j` を `0` にしておき、`j+1` (`1`)番目の要素を `val` で上書きします。  

　アルゴリズムの詳しい解説は、本のcode 12.1などを参照してください。  
<br>

　実装した関数を試してみます。  

　要素数を指定して、数列を作成します。

```{r}
# 要素数を指定
N <- 50

# 数列を生成
a <- sample(x = 1:(2*N), size = N, replace = TRUE)
a
```

　乱数生成関数 `sample()` などで数値ベクトルを生成します。  

　挿入ソートにより並べ替えます。

```{r}
# ソート
insertion_sort(a)
```

　目で確認するのはアレなので、組み込み関数のソート結果と比較して確認します。

```{r}
# 確認
sum(!(insertion_sort(a) == sort(a)))
```

　`!` で `TRUE, FALSE` を反転させて `sum()` で合計することで、一致しない要素数を得られます。結果が `0` であれば全ての要素が一致したことが分かります。  
<br>


## ソートの可視化

　次は、挿入ソートのアルゴリズムをグラフで確認します。  
<br>

　数列の初期値を作成して、グラフで確認します。  

　要素数を指定して、数列を作成します。

```{r}
# 要素数を指定
N <- 20

# 数列を生成
a <- rnorm(n = N, mean = 0, sd = 1) |> 
  round(digits = 1)
table(a)
```

　この例では、(負の値を含めるため)正規乱数生成関数 `rnorm()` で値を生成して、(重複を含めるため)丸め込み関数 `round()` で小数第一位にしておきます。  

　数列をデータフレームに格納します。  

```{r}
# 要素数を取得
N <- length(a)

# 数列を格納
tmp_df <- tibble::tibble(
  iteration = 0,   # 試行回数
  id        = 1:N, # 元のインデックス
  index     = 1:N, # 各試行のインデックス
  value     = a    # 要素
)
tmp_df
```

　作図用に、インデックスなどの値とあわせて数列を格納します。数列のみが与えられている場合は、要素数を `N` とします。  

　数列を棒グラフで確認します。

```{r, fig.width=8, fig.height=6, dpi=100}
# 数列を作図
ggplot() + 
  geom_bar(data = tmp_df, 
           mapping = aes(x = index, y = value, fill = factor(value)), stat = "identity") + 
  theme(panel.grid.minor.x = element_blank()) + # 図の体裁
  labs(title = "numerical sequence", 
       subtitle = paste0("iteration: ", unique(tmp_df[["iteration"]])), 
       fill = "value", 
       x = "index", y = "value")
```

　この要素(バー)を昇順に並べ替えます。  
<br>

　アルゴリズムに従いソートを行って、作図用のデータを作成します。  

　1データずつ入れ替え処理を行い、数列を記録します。

```{r}
# 作図用のオブジェクトを初期化
id_vec   <- 1:N
trace_df <- tmp_df

# 挿入ソート
for(i in 1:N) {
  if(i > 1) { # (初回は不要)
    
    # i番目の値を取得
    v <- a[i]
    
    # i番目から逆順に挿入位置jを探索:(j ≤ i)
    for(j in (i-1):0) { # (i番目は不要・0番目は挿入処理との兼ね合い用)
      
      # j番目とi番目の値を大小比較
      if(j <= 0) {
        
        # 全要素を比較したらループを終了
        break
        
      } else if(a[j] > v) {
        
        # j番目の値を1つ後に移動
        a[j+1] <- a[j]
        id_vec[1:N] <- replace(x = id_vec, list = j+1, values = id_vec[j])
        
      } else {
        
        # i番目の値以下ならループを終了
        break
      }
    }
    
    # i番目の値をj番目に挿入
    a[j+1] <- v
    id_vec[1:N] <- replace(x = id_vec, list = j+1, values = i)
  }
  
  # 数列を格納
  tmp_df <- tibble::tibble(
    iteration = i, 
    id        = id_vec, 
    index     = 1:N, 
    value     = a
  )
  
  # 数列を記録
  trace_df <- dplyr::bind_rows(trace_df, tmp_df)
  
  # 途中経過を表示
  #print(paste0("--- iteration: ", i, " ---"))
  #print(a)
}
```

　「ソートの実装」のときと同様にして、要素を入れ替えていきます。  
　数列 `a` の初期値のインデックス(`1` から `N` の整数)を `id_vec` としておき、`a` の要素の入れ替えに対応するように `id_vec` の要素も入れ替えます。  
　試行ごとに、数列やインデックスをデータフレームに保存します。  
<br>

　初期値のときのコードで、ソートした数列をグラフで確認します。

```{r, echo=FALSE, fig.width=8, fig.height=6, dpi=100}
### 資料作成用:(再掲)

# 数列を作図
ggplot() + 
  geom_bar(data = tmp_df, 
           mapping = aes(x = index, y = value, fill = factor(value)), stat = "identity") + 
  theme(panel.grid.minor.x = element_blank()) + # 図の体裁
  labs(title = "numerical sequence", 
       subtitle = paste0("iteration: ", unique(tmp_df[["iteration"]])), 
       fill = "value", 
       x = "index", y = "value")
```

　昇順に並んでいるのが分かります。  
<br>

　各試行の数列のグラフを並べて推移を確認します。  

　挿入データの描画用のデータフレームを作成します。

```{r}
# 挿入データを作成
target_df <- trace_df |> 
  dplyr::filter(iteration == id) # i番目の要素を抽出
target_df
```

　試行回数(`iteration` 列)と元のインデックス(`id` 列)が一致するデータ(行)を抽出します。  

　試行ごとに数列のグラフを作成します。

```{r, fig.width=12, fig.height=12, dpi=100}
# 全試行の数列を作図
ggplot() + 
  geom_bar(data = trace_df, 
           mapping = aes(x = index, y = value, fill = factor(value)), stat = "identity") + # 全ての要素
  geom_bar(data = target_df,
           mapping = aes(x = id, y = value), stat = "identity",
           color = "red", alpha = 0, linewidth = 0.5, linetype = "dashed") + # 挿入前のi番目の要素
  geom_bar(data = target_df,
           mapping = aes(x = index, y = value), stat = "identity",
           color = "red", alpha = 0, linewidth = 0.5, linetype = "dotted") + # 挿入後のi番目の要素
  geom_segment(data = target_df, 
               mapping = aes(x = id, y = value, xend = -Inf, yend = value, color = factor(value)), 
               linewidth = 0.5, linetype = "dashed", show.legend = FALSE) + # 挿入データまでの上限値
  facet_wrap(iteration ~ ., scales = "free_x", labeller = label_both) + # 試行ごとに分割
  theme(panel.grid.minor.x = element_blank(), 
        legend.position = "right") + 
  labs(title = "insertion sort", 
       fill = "value", 
       x = "index", y = "value")
```

　`facet_wrap()` で、試行(`iteration` 列)ごとに分割して棒グラフを描画します。  
　挿入前の要素(バー)の位置は元のインデックス(`id` 列)、挿入後の位置は `iteration` 回目時点のインデックス(`index` 列)を使います。  

　初期値を0回目として、N回目までの「入れ替え後の数列」をそれぞれ棒グラフ(バー)で表します。  
　i回目の試行(i+1枚目のグラフ)において、挿入した要素を赤色の枠線のバー、またその値を水平線で示します。破線のバーが挿入前の位置、点線のバーが挿入後の位置です。  
　挿入前の位置より左(小さいインデックス)の要素(バー)はソート済み、右(大きいインデックス)の要素(バー)は未処理のデータです。  
　挿入後の位置より左の要素は挿入した要素よりも値(高さ)が小さく、右の要素は値が大きいのが分かります。  
<br>

　各試行の数列のグラフを切り替えて推移を確認します。  

　同様に、挿入データの描画用のデータフレームを作成します。

```{r}
# 挿入データを作成
target_df <- trace_df |> 
    dplyr::filter((iteration + 1) == index) # i番目の要素を抽出
target_df
```

　こちらは、試行回数(`iteration` 列)と元のインデックス(`id` 列)が一致する要素の1試行前のデータを抽出します。  

　重複ラベルの描画用のデータフレームを作成します。

```{r}
# 重複ラベルを作成
dup_label_df <- trace_df |> 
  dplyr::arrange(iteration, id) |> # IDの割当用
  dplyr::group_by(iteration, value) |> # IDの割当用
  dplyr::mutate(
    dup_id    = dplyr::row_number(id), # 重複IDを割り当て
    dup_num   = max(dup_id), # 重複の判定用
    dup_label = dplyr::if_else(
      condition = dup_num > 1, 
      true = paste0("(", dup_id, ")"), 
      false = ""
    ) # 重複要素のみラベルを作成
  ) |> 
  dplyr::ungroup() |> 
  dplyr::arrange(iteration, index)
dup_label_df
```

　重複している値の要素にのみ、それぞれ通し番号のラベルを作成します。  

　推移のアニメーションを作成します。

```{r}
# ソートのアニメーションを作図
graph <- ggplot() + 
  geom_bar(data = trace_df, 
           mapping = aes(x = index, y = value, fill = factor(value), group = factor(id)), stat = "identity") + # 全要素
  geom_bar(data = target_df,
           mapping = aes(x = index, y = value, group = factor(id)), stat = "identity",
           color = "red", alpha = 0, linewidth = 1, linetype = "dashed") + # 挿入データ
  geom_segment(data = target_df,
               mapping = aes(x = index, y = value, xend = -2, yend = value,
                             color = factor(value), group = factor(id)),
               linewidth = 1, linetype = "dashed", show.legend = FALSE) + # 挿入データまでの上限値
  geom_text(data = trace_df, 
            mapping = aes(x = index, y = 0, label = as.character(value), group = factor(id)), 
            vjust = -0.5, size = 5) + # 要素ラベル
  geom_text(data = dup_label_df, 
            mapping = aes(x = index, y = 0, label = dup_label, group = factor(id)), 
            vjust = 1, size = 4) + # 重複ラベル
  gganimate::transition_states(states = iteration, transition_length = 9, state_length = 1, wrap = FALSE) + # フレーム遷移
  gganimate::ease_aes("cubic-in-out") + # 遷移の緩急
  coord_cartesian(xlim = c(0, N+1)) + # (上限値の線用)
  theme(panel.grid.minor.x = element_blank(), 
        legend.position = "none") + 
  labs(title = "insertion sort", 
       subtitle = "iteration: {next_state}", 
       fill = "value", 
       x = "index", y = "value")

# 1試行当たりのフレーム数を指定
s <- 20

# gif画像を作成
gganimate::animate(
  plot = graph, 
  nframes = (N+1 + 2)*s, start_pause = s, end_pause = s, fps = 20, 
  width = 800, height = 600, 
  renderer = gganimate::gifski_renderer()
)
```

　`transition_states()` のフレーム制御の引数 `states` に試行回数列 `iteration` を指定して、これまでと同様に作図します。  
　`animate()` の `plot` 引数にグラフオブジェクト、`nframes` 引数にフレーム数を指定して、gif画像を作成します。  
　初期値を含むため試行回数は `N+1` です。`transition_states()` でアニメーションを作成すると、フレーム間の値を補完して、状態の遷移を描画します。遷移のフレームを `s` として、試行回数の `s` 倍の値を `nframes` 引数に指定します。  

　左(1番目)の要素から順番にソートされるのを確認できます。また、重複要素の順序が入れ替わらない(安定性・stable性)も確認できます。  

　ここでの試行回数(iterationの値)は、この可視化方法における試行番号(作図処理上の値)であり他の手法と対応していません。  
<br>

　この記事では、挿入ソートを実装しました。次の記事では、マージソートを実装します。  
<br>


# 12.4 マージソートの実装と可視化

　マージソート(merge sort)を実装します。また、ソートの推移のアニメーションを作成して、アルゴリズムを確認します。  
<br>

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(gganimate)
```

```{r, echo=FALSE}
### 資料作成用

# チェック用
library(ggplot2)
```

　この記事では、基本的に `パッケージ名::関数名()` の記法を使っているので、パッケージを読み込む必要はありません。ただし、作図コードについてはパッケージ名を省略しているので、`ggplot2` を読み込む必要があります。  
　また、ネイティブパイプ演算子 `|>` を使っています。`magrittr` パッケージのパイプ演算子 `%>%` に置き換えても処理できますが、その場合は `magrittr` を読み込む必要があります。  

　「ソートの可視化」において、`gganimate` パッケージを利用してアニメーション(gif画像)を作成します。ソートの実装自体には使いません。  
<br>


## ソートの実装

　まずは、挿入ソートのアルゴリズムを関数として実装します。  
<br>

　挿入ソートを実装します。

```{r}
# マージソートの実装
merge_sort <- function(vec) {
  
  # 入替範囲の要素数を取得
  l <- 1
  r <- length(vec)
  
  # 要素数が1なら再帰処理を終了
  if(r == 1) return(vec)
  
  # 分割位置mを計算:(l ≤ m ≤ r)
  m <- l + (r - l) %/% 2
  
  # 分割してそれぞれソート
  buf <- c(
    merge_sort(vec[l:m]),
    merge_sort(vec[(m+1):r]) |>
      rev()
  )
  
  # 入替範囲内のインデックスを初期化
  idx_l <- 1
  idx_r <- 0
  
  # 要素ごとに処理
  for(i in 1:r) {
    
    # 小さい方の要素を取り出して併合
    if(buf[idx_l] <= buf[r-idx_r]) { # 左側が小さい場合
      
      # 左側の要素をj番目に格納
      vec[i] <- buf[idx_l]
      
      # インデックスを更新
      idx_l  <- idx_l + 1
      
    } else { # 右側が小さい場合
      
      # 右側の要素をj番目に格納
      vec[i] <- buf[r-idx_r]
      
      # インデックスを更新
      idx_r  <- idx_r + 1
    }
  }
  
  # 数列を出力
  return(vec)
}
```

　ソート対象の数列のうち、分割された一部の要素を `vec` として受け取ります。  
　`vec` の要素数を `r` とします。また、`l` を `1` としておきます。（数列全体を見た際のlからrの範囲に対応した変数名です。ここでは一部だけを扱っているので1とnの方が分かりやすいかもしれません。）  
　`vec` (`l` から `r` の範囲)をさらに分割する位置(インデックス)を `m` とします。  

　「`l` 番目から `m` 番目までの要素」と「`m+1` 番目から `r` 番目までの要素」をそれぞれ `merge_sort()` でソートします。  
　2つに分割したうち、「前(1から)の方はそのまま」で「後(m+1から)の方は逆順」にして結合したベクトルを一時変数 `buf` とします。`1` から `m` 番目までは昇順、`m+1` から `r` 番目までは降順に並んだ状態です。  
　頭と尻の要素の大小を(勝ち抜け戦の要領で)比較して、小さい順に取り出して `vec` に格納していきます。  

　`merge_sort()` を実行すると内部でさらに(全ての分割範囲が1になるまで再帰的に) `merge_sort()` が実行され、分割と併合(ソート)が繰り返されて、全体がソートされます。  

　アルゴリズムの詳しい解説は、本のcode 12.2などを参照してください。  
<br>

　実装した関数を試してみます。  

　要素数を指定して、数列を作成します。

```{r}
# 要素数を指定
N <- 50

# 数列を生成
a <- sample(x = 1:(2*N), size = N, replace = TRUE)
a
```

　乱数生成関数 `sample()` などで数値ベクトルを生成します。  

　挿入ソートにより並べ替えます。

```{r}
# ソート
merge_sort(a)
```

　目で確認するのはアレなので、組み込み関数のソート結果と比較して確認します。

```{r}
# 確認
sum(!(merge_sort(a) == sort(a)))
```

　`!` で `TRUE, FALSE` を反転させて `sum()` で合計することで、一致しない要素数を得られます。結果が `0` であれば全ての要素が一致したことが分かります。  
<br>


## ソートの可視化

　次は、挿入ソートのアルゴリズムをグラフで確認します。  
<br>

　数列の初期値を作成して、グラフで確認します。  

　要素数を指定して、数列を作成します。

```{r}
# 要素数を指定
N <- 35

# 数列を生成
a <- rnorm(n = N, mean = 0, sd = 1) |> 
  round(digits = 1)
table(a)
```

　この例では、(負の値を含めるため)正規乱数生成関数 `rnorm()` で値を生成して、(重複を含めるため)丸め込み関数 `round()` で小数第一位にしておきます。  

　数列をデータフレームに格納します。  

```{r}
# 要素数を取得
N <- length(a)

# 数列を格納
tmp_df <- tibble::tibble(
  iteration = 0,   # 試行回数
  id        = 1:N, # 元のインデックス
  index     = 1:N, # 各試行のインデックス
  value     = a    # 要素
)
tmp_df
```

　作図用に、インデックスなどの値とあわせて数列を格納します。数列のみが与えられている場合は、要素数を `N` とします。  

　数列を棒グラフで確認します。

```{r, fig.width=8, fig.height=6, dpi=100}
# 数列を作図
ggplot() + 
  geom_bar(data = tmp_df, 
           mapping = aes(x = index, y = value, fill = factor(value)), stat = "identity") + 
  theme(panel.grid.minor.x = element_blank()) + 
  labs(title = "numerical sequence", 
       subtitle = paste0("iteration: ", unique(tmp_df[["iteration"]])), 
       fill = "value", 
       x = "index", y = "value")
```

　この要素(バー)を昇順に並べ替えます。  
<br>

　アルゴリズムに従いソートを行って、作図用のデータを作成します。  
　この例では、数列の全ての範囲に対して分割または併合を行う処理を1試行とします。再帰的な処理を行うと次の試行になります。ただし実際(関数内部)の処理では、1試行の処理が全て終わる前に再帰処理が行われることもあります。  

　マージソートでは、1要素ずつになるまで数列を二分割していき、分割した数列の一部を(分割時とは逆方向に)併合しながら昇順に並べ替えていくのでした。つまり、要素の入れ替えを行う前に数列を分割しておく必要があります。  
　そこで、数列の分割に対応するインデックスを作成する関数を定義しておきます。

```{r}
# インデックスの分割の実装
trace_idx <- function(mat = NA, iter = 0, left = 1, right = 1) {
  
  # 分割範囲を取得
  i <- iter
  l <- left
  r <- right
  
  # 試行回数をカウント
  if(i == 0) {
    
    # 初回ならマトリクスを初期化
    mat <- matrix(data = NA, nrow = 1, ncol = r)
    i <- 1
    
  } else if(l == 1) {
    
    # 左端の範囲なら行を追加
    mat <- rbind(
      mat, 
      matrix(data = NA, nrow = 1, ncol = ncol(mat))
    )
    i <- i + 1
    
  } else {
    
    i <- i + 1
  }
  
  # 分割位置mを計算:(l ≤ m ≤ r)
  m <- l + (r - l) %/% 2
  
  # 分割範囲のインデックスを格納
  mat[i, l:r] <- 1:(r-l+1)
  
  # 範囲が1なら再帰処理を終了
  if(l == r) return(mat)
  
  # インデックスを取得
  mat <- trace_idx(mat, iter = i, left = l, right = m)
  mat <- trace_idx(mat, iter = i, left = (m+1), right = r)
  
  # インデックスを出力
  return(mat)
}
```

　(分割の仕方自体は重要ではないと思いますが、)`merge_sort()` の内部と同じ挙動になるように(頑張って)処理します。  
　試行ごとにマトリクスに行を追加します。`l` が `1` のとき、つまりソート対象の数列の左端の要素を含む範囲のとき、新たな試行とみなします。  
　分割範囲ごとに通し番号のインデックスを割り当てますが、使うのは `1` の位置(列番号)のみです。  
<br>

　実装した関数を使って、分割した際のインデックスを作成します。

```{r}
# 分割インデックスを作成
trace_idx_mat <- trace_idx(mat = NA, iter = 0, left = 1, right = N)
trace_idx_mat[, 1:5]
```

　分割された範囲の要素数が1になると、その範囲では再帰処理が行われません。そのため、他の範囲で再帰処理が行われると、既に要素数が1の範囲の次の行は欠損値 `NA` になります。  
　`trace_idx()` が出力したマトリクスに対して、`is.na()` が `TRUE` になる要素(欠損値)に `1` を代入します。

```{r}
# 欠損値を補完
trace_idx_mat[is.na(trace_idx_mat)] <- 1
trace_idx_mat[, 1:5]
```

　数列の要素数に応じて、分割(入替)の範囲が決まります。  
　最後の行は、全ての要素が `1` になり、1要素ずつに分割された状態を表し、また併合されていない状態(数列の初期値)を表します。  
<br>

　1データずつ入れ替え処理を行い、数列を記録します。

```{r}
# 試行回数を取得:(初期値は除く)
max_iter <- nrow(trace_idx_mat) - 1

# 作図用のオブジェクトを初期化
id_vec   <- 1:N
trace_df <- tmp_df

# マージソート
for(i in 1:max_iter) {
  
  # 分割範囲のインデックスを作成
  l_idx_vec <- which(trace_idx_mat[max_iter-i+1, ] == 1)
  r_idx_vec <- c(l_idx_vec[-1]-1, N)
  m_idx_vec <- l_idx_vec + (r_idx_vec - l_idx_vec) %/% 2
  
  # 分割数を取得
  max_k <- length(l_idx_vec)
  
  # 分割範囲ごとに処理
  for(k in 1:max_k) {
    
    # 分割範囲を取得
    l <- l_idx_vec[k]
    r <- r_idx_vec[k]
    m <- m_idx_vec[k]
    
    # 前回の要素IDを保存
    old_id_vec <- id_vec
    
    # 数列を分割
    if(l == r) { # 要素数が1の場合
      buf <- a[l]
    } else {
      buf <- c(a[l:m], rev(a[(m+1):r]))
    }
    
    # 分割範囲内のインデックスを初期化
    idx_l <- 1
    idx_r <- 0
    max_r <- length(buf)
    
    # 要素ごとに処理
    for(j in l:r) {
      
      # 小さい方の要素を取り出して併合
      if(buf[idx_l] <= buf[max_r-idx_r]) {
        
        # 左側の要素をj番目に格納
        a[j] <- buf[idx_l]
        id_vec[1:N] <- replace(x = id_vec, list = j, values = old_id_vec[l+idx_l-1])
        
        # インデックスを更新
        idx_l <- idx_l + 1
        
      } else {
        
        # 右側の要素をj番目に格納
        a[j] <- buf[max_r-idx_r]
        id_vec[1:N] <- replace(x = id_vec, list = j, values = old_id_vec[m+idx_r+1])
        
        # インデックスを更新
        idx_r <- idx_r + 1
      }
    }
  }
  
  # 数列を格納
  tmp_df <- tibble::tibble(
    iteration = i, 
    id        = id_vec, 
    index     = 1:N, 
    value     = a
  )
  
  # 数列を記録
  trace_df <- dplyr::bind_rows(trace_df, tmp_df)

  # 途中経過を表示
  #print(paste0("--- iteration: ", i, " ---"))
  #print(a)
}
```

　分割した範囲内のインデックス `trace_idx_mat` の最後の行(初期値に対応するインデックス)を除き、後の行から順番に取り出して処理します。そのため、`trace_idx_mat` の行数-1を試行回数の最大値 `max_iter` とします。  
　`trace_idx_mat` の各行について、値が `1` の要素の列インデックスが、分割範囲の左端のインデックス `l_idx_vec` に対応します。  
　`l_idx_vec` の最初の要素(`1`)を除き、最後に要素数(`N`)を追加したベクトルが、分割範囲の右端のインデックス `r_idx_vec` に対応します。  
　`l_idx_vec, r_idx_vec` から分割点のインデックス `m_idx_vec` を作成します。`m_idx_vec + 1` と `l_idx_vec` の値が併合における1試行前(分割だと1試行後)の `l_idx_vec` の値です。  
　`*_idx_vec` の要素数が各試行の分割数に対応します。  

　分割範囲ごとに分割範囲と分割位置のインデックスと取り出して、「ソートの実装」のときと同様にして、要素を入れ替えていきます。  
　数列 `a` の初期値のインデックス(`1` から `N` の整数)を `id_vec` としておき、`a` の要素の入れ替えに対応するように `id_vec` の要素も入れ替えます。  

　試行ごとに、数列やインデックスをデータフレームに保存します。  
<br>

　初期値のときのコードで、ソートした数列をグラフで確認します。

```{r, echo=FALSE, fig.width=8, fig.height=6, dpi=100}
### 資料作成用:(再掲)

# 数列を作図
ggplot() + 
  geom_bar(data = tmp_df, 
           mapping = aes(x = index, y = value, fill = factor(value)), stat = "identity") + 
  theme(panel.grid.minor.x = element_blank()) + # 図の体裁
  labs(title = "numerical sequence", 
       subtitle = paste0("iteration: ", unique(tmp_df[["iteration"]])), 
       fill = "value", 
       x = "index", y = "value")
```

　昇順に並んでいるのが分かります。  
<br>

　各試行の数列のグラフを並べて推移を確認します。  

　分割範囲(入替範囲)の描画用のデータフレームを作成します。

```{r}
# 入替範囲を作成
range_df <- trace_idx_mat[(max_iter+1):1, ] |> # (逆順に並べ替え)
  tibble::as_tibble(.name_repair = NULL) |> 
  tibble::add_column(iteration = 0:max_iter) |> # 試行回数列を追加
  tidyr::pivot_longer(
    cols = !iteration, 
    names_to = "index", 
    names_prefix = "V", 
    names_transform = list(index = as.numeric), 
    values_to = "split_flag"
  ) |> # 分割インデックス列をまとめる
  dplyr::filter(split_flag == 1) |> # 分割位置を抽出
  dplyr::arrange(iteration, index) |> # 分割範囲の作成用
  dplyr::group_by(iteration) |> # 分割範囲の作成用
  dplyr::mutate(
    # 分割範囲を作成
    left  = index, 
    right = dplyr::lead(index, n = 1, default = N+1), 
    # タイル用
    x      = 0.5 * (right + left - 1), 
    y      = 0.5 * (max(a) + min(c(0, a))), 
    width  = right - left, 
    height = max(a) - min(c(0, a)) + 1
  ) |> 
  dplyr::ungroup()
range_df
```

　分割した範囲内のインデックス `trace_idx_mat` をデータフレームに変換して、`pivot_longer()` で全ての値を1つの列にまとめます。列名(を加工した値)は数列全体のインデックスに対応します。  
　`trace_idx_mat` の行番号の逆順に `0` から `max_iter` までの整数を割り当てて、試行回数列とします。  

　分割範囲内インデックスが `1` の要素(行)を取り出します。抽出された要素の全体のインデックスが、分割範囲の左端の位置lに対応します。また、`1` を除き `N+1` を追加したインデックスが右端の位置rに対応します。  
　そこで、`lead()` で1行前にズラして、最後に(`default` 引数で) `N+1` を追加した列を作成します。  

　試行ごとに数列のグラフを作成します。

```{r, fig.width=12, fig.height=12, dpi=100}
# 全試行の数列を作図
ggplot() + 
  geom_bar(data = trace_df, 
           mapping = aes(x = index, y = value, fill = factor(value)), stat = "identity") + # 全ての要素
  geom_tile(data = range_df,
            mapping = aes(x = x, y = y, width = width, height = height),
            color = "red", alpha = 0, linewidth = 0.6, linetype = "dashed") + # 入替範囲
  facet_wrap(iteration ~ ., scales = "free_x", labeller = label_both) + # 試行ごとに分割
  theme(panel.grid.minor.x = element_blank(), 
        legend.position = "none") + 
  labs(title = "merge sort", 
       fill = "value", 
       x = "index", y = "value")
```

　`facet_wrap()` で、試行(`iteration` 列)ごとに分割して棒グラフを描画します。  
　要素の入れ替えが行われる(分割された)範囲を `geom_tile()` で描画します。（`geom_bar()` を使って範囲を描画しようとすると、描画自体はできるのですが、`width` 引数について警告文が出たので避けました。原因は不明です。）  

　初期値を0回目として、各試行における「入れ替え後の数列」をそれぞれ棒グラフ(バー)で表します。  
　i回目の試行(i+1枚目のグラフ)において、入れ替えの行われる(分割された)範囲を赤色の破線の枠で示します。  
　各枠内の要素(バー)が昇順に並んでいて、隣り合う枠(範囲)が併合しながら全体がソートされるのが分かります。  
<br>

　各試行の数列のグラフを切り替えて推移を確認します。  

　同様に、入替範囲の描画用のデータフレームを作成します。

```{r}
# 入替範囲を作成
range_df <- trace_idx_mat[max_iter:1, ] |> # (最後を除き逆順に並べ替え)
  tibble::as_tibble(.name_repair = NULL) |> 
  tibble::add_column(iteration = 0:(max_iter-1)) |> # 試行回数列を追加
  tidyr::pivot_longer(
    cols = !iteration, 
    names_to = "index", 
    names_prefix = "V", 
    names_transform = list(index = as.numeric), 
    values_to = "split_flag"
  ) |> # 分割インデックス列をまとめる
  dplyr::filter(split_flag == 1) |> # 分割位置を抽出
  dplyr::arrange(iteration, index) |> # 分割範囲の作成用
  dplyr::group_by(iteration) |> # 分割範囲の作成用
  dplyr::mutate(
    # 分割範囲を作成
    left  = index, 
    right = dplyr::lead(index, n = 1, default = N+1), 
    # タイル用
    x      = 0.5 * (right + left - 1), 
    y      = 0.5 * (max(a) + min(c(0, a))), 
    width  = right - left, 
    height = max(a) - min(c(0, a)) + 1
  ) |> 
  dplyr::ungroup() |> 
  dplyr::mutate(
    id = dplyr::row_number() # 通し番号
  )
range_df
```

　こちらは、1試行分タイミングを早めてデータを作成します。  

　重複ラベルの描画用のデータフレームを作成します。

```{r}
# 重複ラベルを作成
dup_label_df <- trace_df |> 
  dplyr::arrange(iteration, id) |> # IDの割当用
  dplyr::group_by(iteration, value) |> # IDの割当用
  dplyr::mutate(
    dup_id    = dplyr::row_number(id), # 重複IDを割り当て
    dup_num   = max(dup_id), # 重複の判定用
    dup_label = dplyr::if_else(
      condition = dup_num > 1, 
      true = paste0("(", dup_id, ")"), 
      false = ""
    ) # 重複要素のみラベルを作成
  ) |> 
  dplyr::ungroup() |> 
  dplyr::arrange(iteration, index)
dup_label_df
```

　重複している値の要素にのみ、それぞれ通し番号のラベルを作成します。  

　推移のアニメーションを作成します。

```{r}
# ソートのアニメーションを作図
graph <- ggplot() + 
  geom_bar(data = trace_df, 
           mapping = aes(x = index, y = value, fill = factor(value)), stat = "identity") + # 全ての要素
  geom_tile(data = range_df,
            mapping = aes(x = x, y = y, width = width, height = height, group = factor(id)),
            color = "red", alpha = 0, linewidth = 1, linetype = "dashed") + # 入替範囲
  geom_text(data = trace_df, 
            mapping = aes(x = index, y = 0, label = as.character(value), group = factor(id)), 
            vjust = -0.5, size = 5) + # 要素ラベル
  geom_text(data = dup_label_df, 
            mapping = aes(x = index, y = 0, label = dup_label, group = factor(id)), 
            vjust = 1, size = 4) + # 重複ラベル
  gganimate::transition_states(states = iteration, transition_length = 9, state_length = 1, wrap = FALSE) + # フレーム遷移
  gganimate::ease_aes("cubic-in-out") + # 遷移の緩急
  theme(panel.grid.minor.x = element_blank(), 
        legend.position = "none") + 
  labs(title = "merge sort", 
       subtitle = "iteration: {next_state}", 
       fill = "value", 
       x = "index", y = "value")

# 1試行当たりのフレーム数を指定
s <- 20

# gif画像を作成
gganimate::animate(
  plot = graph, 
  nframes = (max_iter+1 + 2)*s, start_pause = s, end_pause = s, fps = 20, 
  width = 1200, height = 900, 
  renderer = gganimate::gifski_renderer()
)
```

　`transition_states()` のフレーム制御の引数 `states` に試行回数列 `iteration` を指定して、これまでと同様に作図します。  
　`animate()` の `plot` 引数にグラフオブジェクト、`nframes` 引数にフレーム数を指定して、gif画像を作成します。  
　初期値を含むため試行回数は `max_iter+1` (`trace_idx_mat` の行数)です。`transition_states()` でアニメーションを作成すると、フレーム間の値を補完して、状態の遷移を描画します。遷移のフレームを `s` として、試行回数の `s` 倍の値を `nframes` 引数に指定します。  

　分割された範囲が併合する度にソートされるのを確認できます。また、重複要素の順序が入れ替わらない(安定性・stable性)も確認できます。  

　ここでの試行回数(iterationの値)は、この可視化方法における試行番号(作図処理上の値)であり他の手法と対応していません。  
<br>

　この記事では、マージソートを実装しました。次の記事では、クイックソートを実装します。  
<br>


# 12.5 クイックソートの実装と可視化



　この記事では、クイックソートを実装しました。次の記事では、ヒープソートを実装します。  
<br>


# 12.6 ヒープソートの実装と可視化



　この記事では、ヒープソートを実装しました。次の記事では、バケットソートを実装します。  
<br>


# 12.8 バケットソートの実装と可視化

　バケットソート(bucket sort)を実装します。また、ソートの推移のアニメーションを作成して、アルゴリズムを確認します。  
<br>

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(patchwork)
library(gganimate)
```

```{r, echo=FALSE}
### 資料作成用

# チェック用
library(ggplot2)
```

　この記事では、基本的に `パッケージ名::関数名()` の記法を使っているので、パッケージを読み込む必要はありません。ただし、作図コードについてはパッケージ名を省略しているので、`ggplot2` を読み込む必要があります。  
　また、ネイティブパイプ演算子 `|>` を使っています。`magrittr` パッケージのパイプ演算子 %>% に置き換えても処理できますが、その場合は `magrittr` を読み込む必要があります。  

　「ソートの可視化」において、`patchwork` パッケージを利用して複数のグラフを並べて描画、`gganimate` パッケージを利用してアニメーション(gif画像)を作成します。ソートの実装自体には使いません。  
<br>


## ソートの実装

　まずは、バケットソートのアルゴリズムを関数として実装します。  
<br>

　挿入ソートを実装します。

```{r}
# バケットソートの実装
bucket_sort <- function(vec, max_val = NA) {
  
  # 数列の要素数を取得
  N <- length(vec)
  
  # 最大値を設定
  if(is.na(max_val)) {
    max_val <- max(vec)
  }
  
  # 集計用の中間変数を初期化
  num_vec <- rep(x = 0, times = max_val)
  sum_vec <- rep(x = 0, times = max_val)
  val_vec <- rep(x = NA, times = N)
  
  # 要素ごとに処理
  for(i in 1:N) { # (前から)
    
    # 重複数をカウント
    num_vec[vec[i]] <- num_vec[vec[i]] + 1
  }
  
  # 値ごとに処理
  for(v in 1:max_val) {
    
    # 累積要素数をカウント
    if(v == 1) { # (初回)
      sum_vec[v] <- num_vec[v]
    } else {
      sum_vec[v] <- sum_vec[v-1] + num_vec[v]
    }
  }
  
  # 要素ごとに処理
  for(i in N:1) { # (後から)
    
    # 累積要素数番目に値を格納
    val_vec[sum_vec[vec[i]]] <- vec[i]
    
    # 累積要素数をカウントダウン
    sum_vec[vec[i]] <- sum_vec[vec[i]] - 1
  }
  
  # 数列を更新
  vec <- val_vec
  
  # 数列を出力
  return(vec)
}
```

　全ての要素が正の整数の数列を `vec`、数列の要素数を `N` とします。（本だと0以上の整数ですが、Rはインデックスが1からなので0より大きい整数とします。0を含める場合は、処理の前に数列全体に1を足しておきソート後の出力の前に1を引けばいいと思いますが、この例では扱いません。）  
　また、中間変数として扱う際の最大値を `max_val` として指定します。指定しない場合は、`max()` で実際の最大値を設定しますが、ソート前に最大値を得るのはおかしいのかもしれません。）  

　`vec` の各要素が正の整数であるのを利用して、`vec` に格納されている値(`1` から `max_val` までの整数)ごとの要素数をカウントします。初期値が全て `0` のベクトル `num_vec` の `vec[i]` 番目(`i` は `1` から `N` までの整数)に `1` を足していくことで、要素数が得られます。  
　`num_vec` を用いて累積要素数をカウントします。整数 `v-1` までの累積要素数 `sum_vec[v-1]` と整数 `v` の要素数 `num_vec[v]` を足すことで、`vec` に含まれる要素数の累積和(整数 `v` までの要素数)が得られます。  
　`sum_vec` を用いて昇順に要素を並べ換えます。`i` 番目の要素の値(整数) `vec[i]` の累積要素数 `sum_vec[vec[i]]` 番目に値 `vec[i]` を格納し、`sum_vec[vec[i]]` のカウントを1つ減らしていく(`i` は `N` から `1` までの(逆順の)整数)ことで、昇順に並んだベクトルを得られます。  

　アルゴリズムの詳しい解説は、本のcode 12.5などを参照してください。  
<br>

　実装した関数を試してみます。  

　要素数と最大値を指定して、数列を作成します。

```{r}
# 要素数を指定
N <- 50

# 最大値を指定
max_val <- 100

# 数列を生成
a <- sample(x = 1:max_val, size = N, replace = TRUE)
a
```

　乱数生成関数 `sample()` などで数値ベクトルを生成します。  

　バケットソートにより並べ替えます。

```{r}
# ソート
bucket_sort(a, max_val = max_val)
```

　目で確認するのはアレなので、組み込み関数のソート結果と比較して確認します。

```{r}
# 確認
sum(!(bucket_sort(a, max_val) == sort(a)))
```

　`!` で `TRUE, FALSE` を反転させて `sum()` で合計することで、一致しない要素数を得られます。結果が `0` であれば全ての要素が一致したことが分かります。  
<br>


## ソートの可視化

　次は、挿入ソートのアルゴリズムをグラフで確認します。  
<br>

　数列の初期値を作成して、グラフで確認します。  

　要素数と最大値を指定して、数列を作成します。

```{r}
# 要素数を指定
N <- 30

# 最大値を指定
max_val <- 20

# 数列を生成
a <- sample(x = 1:max_val, size = N, replace = TRUE)
table(a)
```

　「ソートの実装」のときのコードで数列を作成します。  

　数列をデータフレームに格納します。  

```{r}
# 要素数を取得
N <- length(a)

# 数列を格納
seq_df <- tibble::tibble(
  index = 1:N, # 各試行のインデックス
  value = a    # 要素
  #value = bucket_sort(a) # 要素
)
seq_df
```

　作図用に、インデックスとあわせて数列を格納します。数列のみが与えられている場合は、要素数を `N` とします。  

　数列を棒グラフで確認します。

```{r, fig.width=8, fig.height=6, dpi=100}
# 数列を作図
ggplot() + 
  geom_bar(data = seq_df, 
           mapping = aes(x = index, y = value, fill = factor(value)), stat = "identity") + 
  theme(panel.grid.minor.x = element_blank()) + # 図の体裁
  labs(title = "numerical sequence", 
       fill = "value", 
       x = "index", y = "value")
```

　この要素(バー)を昇順に並べ替えます。  
<br>

　簡易版と詳細版の2つのアニメーションでアルゴリズムを確認します。  
<br>


### 操作の確認

　作図用に、アルゴリズムに従う途中経過のデータを作成します。  

　数列の初期値の描画用のデータフレームを作成します。

```{r}
# 数列を格納
sequence_df <- tibble::tibble(
  iteration = 0, # フレーム番号
  id        = 1:N, # 要素ID
  # 数列用
  index = 1:N, 
  value = a, 
  # タイル用
  x        = index, 
  y        = 0.5 * value, 
  height   = value, 
  alpha    = 1, 
  linetype = "blank", 
  # ラベル用
  label_y = 0
) |> 
  dplyr::group_by(value) |> # IDの割当用
  dplyr::mutate(
    # 重複ラベル用
    dup_id    = dplyr::row_number(id), # 重複IDを割り当て
    dup_num   = max(dup_id), # 重複の判定用
    dup_label = dplyr::if_else(
      condition = dup_num > 1, true = paste0("(", dup_id, ")"), false = ""
    ) # 重複要素のみラベルを作成
  ) |> 
  dplyr::ungroup()
sequence_df |> 
  dplyr::select(!c(height, alpha, linetype, dup_id, dup_num)) # 資料作成用に間引き
```

　数列のインデックスと値を格納して、作図用の値(列)を作成します。  
　重複している値の要素にのみ、それぞれ通し番号のラベルを作成します。  
　アニメーション用のフレーム番号を `0` とし、以降は通し番号を指定します。  

　数列の初期値の棒グラフを作成します。

```{r, fig.width=15, fig.height=9, dpi=100}
# 数列を作図
sequence_graph <- ggplot() + 
  geom_tile(data = sequence_df,
            mapping = aes(x = x, y = y, width = 1, height = height, fill = factor(value))) + # 全要素
  # geom_bar(data = sequence_df, 
  #          mapping = aes(x = x, y = value, fill = factor(value)), stat = "identity") + # 全要素
  geom_text(data = sequence_df, 
            mapping = aes(x = x, y = label_y, label = as.character(value)), 
            vjust = -1.5, size = 5) + # 要素ラベル
  geom_text(data = sequence_df, 
            mapping = aes(x = x, y = label_y, label = dup_label), 
            vjust = -0.5, size = 4) + # 重複ラベル
  coord_equal(ratio = 1, xlim = c(1, N), ylim = c(0, max_val)) + # アスペクト比
  theme(panel.grid.minor.x = element_blank(), 
        legend.position = "none") + 
  labs(title = "numerical sequence", 
       subtitle = "initial value", 
       fill = "value", 
       x = "index", y = "value")
sequence_graph
```

　アニメーションの作図の確認として `geom_tile()` でバーを描画しています。x軸(`x` 引数)を数列のインデックス、y軸(`y` 引数)を数列の半分の値、高さ(`height` 引数)を数列の値にすると、数列に対応した棒グラフを描画できます。  
　`geom_bar()` でバーを描画する場合は、`y` 引数に `value` 列を指定します。  

　値ごとの要素数の描画用のデータフレームを作成します。

```{r}
# 値ごとの要素数をカウント
count_df <- tibble::tibble(
  iteration = 1, # フレーム番号
  id        = 1:N, # 要素ID
  # 数列用
  value = a, 
  # タイル用
  x       = value, 
  height  = 1, 
  alpha   = 0.1, 
  linetype = "dashed"
) |> 
  dplyr::group_by(value) |> # IDの割当・カウント用
  dplyr::mutate(
    count = dplyr::row_number(id), # 値ごとの累積要素数
    y     = count - 0.5, 
    # ラベル用
    label_y = y - 0.5, 
    # 重複ラベル用
    dup_id    = dplyr::row_number(id), # 重複IDを割り当て
    dup_num   = max(dup_id), # 重複の判定用
    dup_label = dplyr::if_else(
      condition = dup_num > 1, true = paste0("(", dup_id, ")"), false = ""
    ) # 重複要素のみラベルを作成
  ) |> 
  dplyr::ungroup()
count_df |> 
  dplyr::select(!c(height, alpha, linetype, dup_id, dup_num)) # 資料作成用に間引き
```

　値ごとに(`value` 列でグループ化して)、`row_number()` を使って要素IDの小さい順に累積要素数を割り当てます(重複IDの割り当てと同じ処理です)。  

　数列に含まれる値ごとの要素数の積み上げ棒グラフを作成します。

```{r, fig.width=15, fig.height=6, dpi=100}
# 最大値を取得
max_cnt <- max(count_df[["count"]]) + 1

# 値ごとの要素数を作図
count_graph <- ggplot() + 
  geom_tile(data = count_df,
            mapping = aes(x = x, y = y, width = 1, height = height,
                          fill = factor(value), color = factor(value)),
            alpha = 0.1, linewidth = 0.6, linetype = "dashed") + # 全要素
  # geom_bar(data = count_df, 
  #          mapping = aes(x = x, y = 1, fill = factor(value), color = factor(value)), 
  #          stat = "identity", position = "stack", width = 1, 
  #          alpha = 0.1, linewidth = 0.6, linetype = "dashed") + # 全要素
  geom_text(data = count_df, 
            mapping = aes(x = x, y = label_y, label = as.character(value)), 
            vjust = -1.5, size = 3) + # 要素ラベル
  geom_text(data = count_df, 
            mapping = aes(x = x, y = label_y, label = dup_label), 
            vjust = -0.5, size = 2) + # 重複ラベル
  coord_equal(ratio = 1, xlim = c(1, N), ylim = c(0, max_cnt)) + # アスペクト比
  theme(panel.grid.minor.x = element_blank(), 
        legend.position = "none") + 
  labs(title = "count", 
       fill = "value", 
       x = "value", y = "count")
count_graph
```

　x軸(`x` 引数)を数列の値、y軸(`y` 引数)を値ごとの累積要素数から半タイル分ズラした(`0.5` を引いた)値、高さ(`height` 引数)を `1` にすると、数列の要素数に対応した棒グラフを描画できます。  
　`geom_bar()` を使う場合は、`y` 引数に `1`、`position = "stack"` (デフォルト)を指定して積み上げ棒グラフとして描画します。  

　累積要素数とインデックスの対応関係の描画用のデータフレームを作成します。

```{r}
# 累積要素数をカウント
reorder_df <- tibble::tibble(
  iteration = 2, # フレーム番号
  id        = 1:N, # 要素ID
  # 数列用
  value = a, 
  # タイル用
  y        = 0.5, 
  height   = 1, 
  alpha    = 0.1, 
  linetype = "dashed", 
  # ラベル用
  label_y = y - 0.5
) |> 
  dplyr::arrange(value, id) |> # 累積カウント用
  dplyr::mutate(
    x = dplyr::row_number() # 累積要素数
  ) |> 
  dplyr::arrange(id) |> 
  dplyr::group_by(value) |> # IDの割当用
  dplyr::mutate(
    # 重複ラベル用
    dup_id    = dplyr::row_number(id), # 重複IDを割り当て
    dup_num   = max(dup_id), # 重複の判定用
    dup_label = dplyr::if_else(
      condition = dup_num > 1, true = paste0("(", dup_id, ")"), false = ""
    ) # 重複要素のみラベルを作成
  ) |> 
  dplyr::ungroup()
reorder_df |> 
  dplyr::select(!c(height, alpha, linetype, dup_id, dup_num)) # 資料作成用に間引き
```

　値と要素IDの小さい順に、`row_number()` を使って通し番号を割り当てます。  

　昇順の値ごとの累積要素数の棒グラフを作成します。

```{r, fig.width=15, fig.height=6, dpi=100}
# 累積要素数を作図
reorder_graph <- ggplot() + 
  geom_tile(data = reorder_df,
            mapping = aes(x = x, y = y, width = 1, height = height,
                          fill = factor(value), color = factor(value)),
            alpha = 0.1, linewidth = 0.6, linetype = "dashed") + # 全要素
  # geom_bar(data = reorder_df, 
  #          mapping = aes(x = x, y = 1, fill = factor(value), color = factor(value)), 
  #          stat = "identity", width = 1, 
  #          alpha = 0.1, linewidth = 0.6, linetype = "dashed") + # 全要素
  geom_text(data = reorder_df, 
            mapping = aes(x = x, y = label_y, label = as.character(value)), 
            vjust = -1.5, size = 3) + # 要素ラベル
  geom_text(data = reorder_df, 
            mapping = aes(x = x, y = label_y, label = dup_label), 
            vjust = -0.5, size = 2) + # 重複ラベル
  coord_equal(ratio = 1, xlim = c(1, N), ylim = c(0, max_cnt)) + # アスペクト比
  theme(panel.grid.minor.x = element_blank(), 
        legend.position = "none") + 
  labs(title = "cumulative sum", 
       fill = "value", 
       x = "value", y = "count")
reorder_graph
```

　x軸(`x` 引数)を累積要素数(昇順の通し番号)、y軸(`y` 引数)を `0.5`、高さ(`height` 引数)を `1` にすると、昇順のインデックスに対応した棒グラフを描画できます。  
　`geom_bar()` を使う場合は、`y` 引数に `1` を指定します。  

　昇順にソートした数列の描画用のデータフレームを作成します。

```{r}
# 数列をソート
swap_df <- tibble::tibble(
  iteration = 3, # フレーム番号
  id        = 1:N, # 要素ID
  # 数列用
  value = a, 
  # タイル用
  y        = 0.5 * value, 
  height   = value, 
  alpha    = 1, 
  linetype = "blank", 
  # ラベル用
  label_y = 0
) |> 
  dplyr::arrange(value, id) |> # 入替用
  dplyr::mutate(
    index = dplyr::row_number(), # 入替後のインデックス
    x     = index
  ) |> 
  dplyr::arrange(id) |> 
  dplyr::group_by(value) |> # IDの割当用
  dplyr::mutate(
    # 重複ラベル用
    dup_id    = dplyr::row_number(id), # 重複IDを割り当て
    dup_num   = max(dup_id), # 重複の判定用
    dup_label = dplyr::if_else(
      condition = dup_num > 1, true = paste0("(", dup_id, ")"), false = ""
    ) # 重複要素のみラベルを作成
  ) |> 
  dplyr::ungroup()
swap_df |> 
  dplyr::select(!c(height, alpha, linetype, dup_id, dup_num)) # 資料作成用に間引き
```

　値と要素IDの小さい順に、`row_number()` を使ってインデックス(通し番号)を割り当てます。  

　昇順に並べ替えた数列の棒グラフを作成します。

```{r, fig.width=15, fig.height=9, dpi=100}
# ソート済み数列を作図
swap_graph <- ggplot() + 
  geom_tile(data = swap_df,
            mapping = aes(x = x, y = y, width = 1, height = height, fill = factor(value))) + # 全要素
  # geom_bar(data = swap_df, 
  #          mapping = aes(x = x, y = value, fill = factor(value)), 
  #          stat = "identity") + # 全要素
  geom_text(data = swap_df, 
            mapping = aes(x = x, y = label_y, label = as.character(value)), 
            vjust = -1.5, size = 5) + # 要素ラベル
  geom_text(data = swap_df, 
            mapping = aes(x = x, y = label_y, label = dup_label), 
            vjust = -0.5, size = 4) + # 重複ラベル
  coord_equal(ratio = 1, xlim = c(1, N), ylim = c(0, max_val)) + # アスペクト比
  theme(panel.grid.minor.x = element_blank(), 
        legend.position = "none") + 
  labs(title = "bucket sort", 
       fill = "value", 
       x = "index", y = "value")
swap_graph
```

　x軸(`x` 引数)を累積要素数(昇順の通し番号)、y軸(`y` 引数)を数列の半分の値、高さ(`height` 引数)を数列の値にすると、数列に対応した棒グラフを描画できます。  
　`geom_bar()` でバーを描画する場合は、`y` 引数に `value` 列を指定します。  
<br>

　各操作のグラフを並べて推移を確認します。  

　4つのグラフを並べて描画します。

```{r, fig.width=20, fig.height=10, dpi=100}
# 並べて描画
patchwork::wrap_plots(
  sequence_graph, swap_graph, 
  count_graph, reorder_graph, 
  nrow = 2, ncol = 2, widths = 1, heights = c(1, max_cnt/max_val)
)
```

　`wrap_plots()` を使って複数のグラフを1つにまとめて描画します。  
<br>

　各操作のグラフを切り替えて推移を確認します。  

　4つのデータフレームをまとめます。

```{r}
# データを結合
trace_df <- dplyr::bind_rows(
  sequence_df, 
  count_df, 
  reorder_df, 
  swap_df
)
trace_df |> 
  dplyr::arrange(iteration, id)
```

　`bind_rows()` で複数のデータフレームを行方向に結合します。  

　4つの操作のアニメーションを作成します。

```{r}
# ソートのアニメーションを作図
graph <- ggplot() + 
  geom_tile(data = trace_df, 
            mapping = aes(x = x, y = y, width = 1, height = height, 
                          fill = factor(value), color = factor(value), alpha = alpha, 
                          linetype = linetype, group = factor(id)), 
            linewidth = 1) + # 全要素
  geom_text(data = trace_df, 
            mapping = aes(x = x, y = label_y, label = as.character(value), group = factor(id)), 
            vjust = -1.5, size = 5) + # 要素ラベル
  geom_text(data = trace_df, 
            mapping = aes(x = x, y = label_y, label = dup_label, group = factor(id)), 
            vjust = -0.5, size = 4) + # 重複ラベル
  gganimate::transition_states(states = iteration, transition_length = 9, state_length = 1, wrap = FALSE) + # フレーム遷移
  gganimate::ease_aes("cubic-in-out") + # 遷移の緩急
  scale_linetype_identity() + 
  scale_linewidth_identity() + 
  scale_y_continuous(sec.axis = sec_axis(trans = ~-., name = "count")) + # (操作の確認用)
  coord_equal(ratio = 1) + # アスペクト比
  theme(panel.grid.minor.x = element_blank(), 
        legend.position = "none") + 
  labs(title = "bucket sort", 
       subtitle = "iteration: {next_state}", 
       fill = "value", 
       x = "index, value", y = "value, count")

# フレーム数を取得
frame_num <- trace_df[["iteration"]] |> 
  (\(vec) {max(vec) + 1})()

# 1試行当たりのフレーム数を指定
s <- 20

# gif画像を作成
gganimate::animate(
  plot = graph, 
  nframes = (frame_num + 2)*s, start_pause = s, end_pause = s, fps = 20, 
  width = 1000, height = 800, 
  renderer = gganimate::gifski_renderer()
)
```

　`transition_states()` のフレーム制御の引数 `states` にフレーム番号列 `iteration` を指定して、要素の値や要素数の対応関係が補完されるように `geom_tile()` で棒グラフを描画します。  
　`animate()` の `plot` 引数にグラフオブジェクト、`nframes` 引数にフレーム数を指定して、gif画像を作成します。  
　フレーム数は `4` です。`transition_states()` でアニメーションを作成すると、フレーム間の値を補完して、状態の遷移を描画します。遷移のフレームを `s` として、試行回数の `s` 倍の値を `nframes` 引数に指定します。  

　元の「数列の値」、「値ごとの要素数」、昇順にカウントした「累積要素数」、ソート後の「数列のインデックス」の対応関係を確認できます。  
<br>


### 入替の確認

　続いて「ソートの実装」のアルゴリズムに対応するように、数列の前の要素からカウントし、後の要素から配置していくデータを作成します。  

　カウント時の数列の描画用のデータフレームを作成します。

```{r}
# インデックスの小さい順に要素を取り出す
sequence_df <- tidyr::expand_grid(
  iteration = 0:N, # カウント時の試行回数
  id        = 1:N  # 元のインデックス
) |> # 試行ごとに要素IDを複製
  dplyr::mutate(
    # 数列用
    index = id, 
    value = a[id], 
    # タイル用
    x        = index, 
    y        = 0.5 * value, 
    height   = value, 
    alpha    = 1, 
    linetype = "blank", 
    # ラベル用
    label_y = 0
  ) |> 
  dplyr::group_by(iteration, value) |> # IDの割当用
  dplyr::mutate(
    # 重複ラベル用
    dup_id    = dplyr::row_number(id), # 重複IDを割り当て
    dup_num   = max(dup_id), # 重複の判定用
    dup_label = dplyr::if_else(
      condition = dup_num > 1, true = paste0("(", dup_id, ")"), false = ""
    ) # 重複要素のみラベルを作成
  ) |> 
  dplyr::ungroup() |> 
  dplyr::filter(iteration < id) # 未カウントの要素を抽出
sequence_df |> 
  dplyr::select(!c(height, alpha, linetype, dup_id, dup_num)) # 資料作成用に間引き
```

　試行番号(初期値を `0` として `N` までの整数)と要素ID(初期値のインデックス)(`1` から `N` までの整数)の全ての組み合わせを `expand_grid()` で作成します。  
　「操作の確認」のときと同様に処理して、未カウントの要素(試行番号よりIDが大きい行)を抽出します。  

　カウント時の値ごとの要素数の描画用のデータフレームを作成します。

```{r}
# インデックスの小さい順に要素を取り出してカウント
count_df <- tidyr::expand_grid(
  iteration = 0:N, # カウント時の試行回数
  id        = 1:N  # 元のインデックス
) |> # 試行ごとに要素IDを複製
  dplyr::mutate(
    # 数列用
    value = a[id], 
    # タイル用
    x        = value, 
    height   = 1, 
    alpha    = 0.1, 
    linetype = "dashed"
  ) |> 
  dplyr::group_by(iteration, value) |> # IDの割当・カウント用
  dplyr::mutate(
    # タイル用
    count = dplyr::row_number(id), # 値ごとの要素数
    y     = -count + 0.5, 
    # ラベル用
    label_y = y - 0.5, 
    # 重複ラベル用
    dup_id    = dplyr::row_number(id), # 重複IDを割り当て
    dup_num   = max(dup_id), # 重複の判定用
    dup_label = dplyr::if_else(
      condition = dup_num > 1, true = paste0("(", dup_id, ")"), false = ""
    ) # 重複要素のみラベルを作成
  ) |> 
  dplyr::ungroup() |> 
  dplyr::filter(iteration >= id) # カウント済みの要素を抽出
count_df |> 
  dplyr::select(!c(height, alpha, linetype, dup_id, dup_num)) # 資料作成用に間引き
```

　「操作の確認」のときと同様に処理して、カウント済みの要素(試行番号がID以上の行)を抽出します。ただし、バーが重ならないようにカウントの符号を反転させた(`-1` を掛けた)値をy軸の値とします。  

　昇順に配置時の累積要素数とインデックスの対応関係の描画用のデータフレームを作成します。

```{r}
# インデックスの小さい順に要素を戻してカウント
discount_df <- tidyr::expand_grid(
  iteration = 0:N + N+1, # 入替時の試行回数
  id        = 1:N # 元のインデックス
) |> # 試行ごとに要素IDを複製
  dplyr::mutate(
    # 数列用
    value = a[id], 
    # タイル用
    y        = -0.5, 
    height   = 1, 
    alpha    = 0.1, 
    linetype = "dashed", 
    # ラベル用
    label_y = y - 0.5
  ) |> 
  dplyr::arrange(iteration, value, id) |> # 累積カウント用
  dplyr::group_by(iteration) |> # 累積カウント用
  dplyr::mutate(
    # タイル用
    x = dplyr::row_number() # 累積要素数
  ) |> 
  dplyr::arrange(iteration, id) |> 
  dplyr::group_by(iteration, value) |> # IDの割当用
  dplyr::mutate(
    # 重複ラベル用
    dup_id    = dplyr::row_number(id), # 重複IDを割り当て
    dup_num   = max(dup_id), # 重複の判定用
    dup_label = dplyr::if_else(
      condition = dup_num > 1, true = paste0("(", dup_id, ")"), false = ""
    ) # 重複要素のみラベルを作成
  ) |> 
  dplyr::ungroup() |> 
  dplyr::filter(iteration-(N+1) < N+1-id) # 未入替の要素を抽出
discount_df |> 
  dplyr::select(!c(height, alpha, linetype, dup_id, dup_num)) # 資料作成用に間引き
```

　カウント時に続く試行番号(`N+1` から `2*N+1` までの整数)と要素ID(`1` から `N` までの整数)の全ての組み合わせを `expand_grid()` で作成します。  
　「操作の確認」のときと同様に処理して、入替前の要素(「試行番号」より「後から数えたID」が大きい行)を抽出します。  

　昇順に配置時の数列の描画用のデータフレームを作成します。

```{r}
# インデックスの小さい順に要素を入れ替えて戻す
swap_df <- tidyr::expand_grid(
  iteration = 0:N + N+1, # 入替時の試行回数
  id        = 1:N # 元のインデックス
) |> # 試行ごとに要素IDを複製
  dplyr::mutate(
    # 数列用
    value = a[id], 
    # タイル用
    y        = 0.5 * value, 
    height   = value, 
    alpha    = 1, 
    linetype = "blank", 
    # ラベル用
    label_y = 0
  ) |> 
  dplyr::arrange(iteration, value, id) |> # 入替用
  dplyr::group_by(iteration) |> # 入替用
  dplyr::mutate(
    # タイル用
    index = dplyr::row_number(), # 入替後のインデックス
    x     = index
  ) |> 
  dplyr::arrange(iteration, id) |> 
  dplyr::group_by(iteration, value) |> # IDの割当用
  dplyr::mutate(
    # 重複ラベル用
    dup_id    = dplyr::row_number(id), # 重複IDを割り当て
    dup_num   = max(dup_id), # 重複の判定用
    dup_label = dplyr::if_else(
      condition = dup_num > 1, true = paste0("(", dup_id, ")"), false = ""
    ) # 重複要素のみラベルを作成
  ) |> 
  dplyr::ungroup() |> 
  dplyr::filter(iteration-(N+1) >= N+1-id) # 入替済みの要素を抽出
swap_df |> 
  dplyr::select(!c(height, alpha, linetype, dup_id, dup_num)) # 資料作成用に間引き
```

　「操作の確認」のときと同様に処理して、入替前の要素(「試行番号」が「後から数えたID」以上の行)を抽出します。  

　4つのデータフレームをまとめます。

```{r}
# データを結合
trace_df <- dplyr::bind_rows(
  sequence_df, 
  count_df, 
  discount_df, 
  swap_df
)
trace_df
```

<br>

　カウント時と配置時のグラフを切り替えて推移を確認します。  

```{r, echo=FALSE}
### 資料作成用:(再掲)

# ソートのアニメーションを作図
graph <- ggplot() + 
  geom_tile(data = trace_df, 
            mapping = aes(x = x, y = y, width = 1, height = height, 
                          fill = factor(value), color = factor(value), alpha = alpha, 
                          linetype = linetype, group = factor(id)), 
            linewidth = 1) + # 全要素
  geom_text(data = trace_df, 
            mapping = aes(x = x, y = label_y, label = as.character(value), group = factor(id)), 
            vjust = -1.5, size = 5) + # 要素ラベル
  geom_text(data = trace_df, 
            mapping = aes(x = x, y = label_y, label = dup_label, group = factor(id)), 
            vjust = -0.5, size = 4) + # 重複ラベル
  gganimate::transition_states(states = iteration, transition_length = 9, state_length = 1, wrap = FALSE) + # フレーム遷移
  gganimate::ease_aes("cubic-in-out") + # 遷移の緩急
  scale_linetype_identity() + 
  scale_linewidth_identity() + 
  scale_y_continuous(sec.axis = sec_axis(trans = ~-., name = "count")) + # (操作の確認用)
  coord_equal(ratio = 1) + # アスペクト比
  theme(panel.grid.minor.x = element_blank(), 
        legend.position = "none") + 
  labs(title = "bucket sort", 
       subtitle = "iteration: {next_state}", 
       fill = "value", 
       x = "index, value", y = "value, count")

# フレーム数を取得
frame_num <- trace_df[["iteration"]] |> 
  (\(vec) {max(vec) + 1})()

# 1試行当たりのフレーム数を指定
s <- 10

# gif画像を作成
gganimate::animate(
  plot = graph, 
  nframes = (frame_num + 2)*s, start_pause = s, end_pause = s, fps = 30, 
  width = 1000, height = 1000, 
  renderer = gganimate::gifski_renderer()
)
```

　「操作の確認」のときのコードで作図します。「初期値」の表示と「値ごとの要素数と累積要素数によるインデックス」の遷移を含めるため、フレーム数は `2*N + 2` です。  
　バーが重ならないように、要素数のカウントを逆向きの積み上げ棒グラフで表しています。  

　左(1番目)の要素から順番にカウントしていき、右(N番目)の要素から逆順に累積要素数に応じて配置していくことでソートされるのを確認できます。また、重複要素の順序が入れ替わらない(安定性・stable性)も確認できます。  

　ここでの試行回数(iterationの値)は、この可視化方法における試行番号(作図処理上の値)であり他の手法と対応していません。  
<br>

　この記事では、バケットソートを実装しました。  
<br>


# 参考文献

- 大槻兼資(著), 秋葉拓哉(監修)『問題解決力を鍛える！　アルゴリズムとデータ構造』講談社サイエンティク, 2021年.


